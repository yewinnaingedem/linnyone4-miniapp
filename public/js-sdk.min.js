!function (e, r) {
    "object" == typeof exports
&& "undefined" != typeof module ? module.exports = r() : "function" == typeof define && define.amd ? define(r) : (e = "undefined" != typeof globalThis ? globalThis : e || self).jssdk = r()
}(this, (function () { "use strict"; var e, r; const n = null === (r = null === (e = null === window || void 0 === window ? void 0 : window.navigator) || void 0 === e ? void 0 : e.userAgent) || void 0 === r ? void 0 : r.toLocaleLowerCase(), t = -1 !== (null == n ? void 0 : n.indexOf("android")), o = Symbol("currentRoute"), a = Symbol("isInitd"), i = Symbol("tabBar"), s = Symbol("canNavigateTo"), l = "__ma__global__", u = { [o]: "", [a]: !1, [i]: null, [s]: !0 }; function c(e, r) { u[e] = r } function d(e) { return window[l][e] } window[l] = u; const f = { MiniProgram: { NAVIGATE_TO: "navigateTo", NAVIGATE_BACK: "navigateBack", REDIRECT_TO: "redirectTo", SWITCH_TAB: "switchTab", RE_LAUNCH: "reLaunch", POST_MESSAGE: "postMessage", CLOSE: "close" }, Native: { CHOOSE_IMAGE: "chooseImage", GET_LOCAL_IMG_DATA: "getLocalImgData", GET_LOCATION: "getLocation", PREVIEW_IMAGE: "previewImage", OPEN_DOCUMENT: "openDocument", GET_STORAGE: "getStorage", SET_STORAGE: "setStorage", REMOVE_STORAGE: "removeStorage", CLEAR_STORAGE: "clearStorage", GET_NETWORK_TYPE: "getNetworkType", SCAN_CODE: "scanCode", GET_STATUS_BAR_HEIGHT: "getStatusBarHeight", CAPSULE_STYLE: "capsuleStyle", HIDE_LOADING: "hideLoading", SHOW_LOADING: "showLoading", SHOW_TOAST: "showToast", GET_SMALL_APP_INFO: "getsmallappinfo", GO_TO_BROWSER: "gotoBrowser", SAVE_FILE_TO_PHONE: "saveFileToPhone", SAVE_IMAGE: "saveImage", SAVE_BASE64_IMAGE: "saveBase64Image", CHOOSE_CONTACT: "chooseContact", IS_ONLINE: "isOnline", REQUEST: "request", UPLOAD_FILE: "uploadFile", DOWNLOAD_FILE: "downloadFile", REPORT_PERFORMANCE: "reportPerformance", REPORT_LOG: "reportLog", SUBMIT_REPORT: "submitReport", PLAY_VOICE: "playVoice", PLAY_AUDIO: "playAudio", GET_BACKGROUND_FETCH_DATA: "getBackgroundFetchData", GET_LAUNCH_OPTIONS_SYNC: "getLaunchOptionsSync", GET_SYSTEM_INFO_SYNC: "getSystemInfoSync", NAVIGATE_TO_MINI_PROGRAM: "navigateToMiniProgram", STOP_AUOID: "stopVoice", GET_OPEN_USER_INFO: "getOpenUserInfo", GET_AUTH_CODE: "getAuthCode" } }, v = void 0 !== window.parent.__simulatorConfig__, m = {}; let E = 0; function _(e, r = {}, n) { const o = JSON.stringify(r), a = ++E; m[a] = n, function (e, r, n) { v ? window.simulatorWebkit.messageHandlers.invoke.postMessage({ command: e, inputParams: r, callbackId: n, type: "legacy" }) : t ? window.viewLayerNative.invoke(e, r, n) : window.webkit.messageHandlers.invoke.postMessage({ command: e, inputParams: r, callbackId: n }) }(e, o, a) } function p(e, r, n = {}) { const t = {}; for (const e in r) "function" == typeof r[e] && (t[e] = r[e], delete r[e]); _(e, r, ((e, r) => { var o, a, i, s, l, u, c, d, f, v, m; const E = 0 === Number(e), _ = [1, -1].includes(Number(e)); E ? (null === (o = null == n ? void 0 : n.beforeAll) || void 0 === o || o.call(n, r), null === (a = null == n ? void 0 : n.beforeSuccess) || void 0 === a || a.call(n, r), null === (i = t.success) || void 0 === i || i.call(t, r), null === (s = null == n ? void 0 : n.afterSuccess) || void 0 === s || s.call(n, r)) : _ ? (null === (l = null == n ? void 0 : n.beforeFail) || void 0 === l || l.call(n, r), null === (u = t.fail) || void 0 === u || u.call(t, r), null === (c = null == n ? void 0 : n.afterFail) || void 0 === c || c.call(n, r)) : (null === (d = null == n ? void 0 : n.beforeSuccess) || void 0 === d || d.call(n, r), null === (f = null == t ? void 0 : t.preload) || void 0 === f || f.call(t, r)), (E || _) && (null === (v = t.complete) || void 0 === v || v.call(t, r), null === (m = null == n ? void 0 : n.afterAll) || void 0 === m || m.call(n, r)) })) } function O(e, r = {}) { const n = JSON.stringify(r); v ? window.simulatorWebkit.messageHandlers.notifyNative.postMessage({ command: e, inputParams: n, type: "legacy" }) : t ? window.viewLayerNative.notifyNative(e, n) : window.webkit.messageHandlers.notifyNative.postMessage({ command: e, inputParams: n }) } const N = {}, T = "ma_custom_event_"; function g(e, r) { N[`${T}${e}`] = r } function S(e, r = {}) { const n = JSON.stringify(r); A(`${T}${e}`, n) } function A(e, r) { v ? window.simulatorWebkit.messageHandlers.notifyNative.postMessage({ eventName: e, paramsString: r, type: "legacy" }) : t ? window.viewLayerNative.notifyNative(e, r) : window.webkit.messageHandlers.notifyNative.postMessage({ eventName: e, paramsString: r }) } const b = { invoke: _, invokeSync: function (e, r) { const n = JSON.stringify(Object.assign({ command: e }, r)); return window.prompt(n) }, invokeMethod: p, beforeInvoke: function (e, r = {}, n = {}) { return r.success || r.fail || r.complete ? p(e, r, n) : new Promise(((t, o) => { r.success = t, r.fail = o, p(e, r, n) })) }, notifyNative: O, subscribe: g, webSubscribe: function (e, r) { N[e] = r }, publish: S, webPublish: function (e, r = {}) { A(e, JSON.stringify(r)) } }; function I() { if (!d(a)) { c(a, !0); try { g("getCurrentRoute", (e => { c(o, e.route), c(i, e.tabBar), c(s, void 0 === e.canNavigateTo || e.canNavigateTo) })), S("getCurrentRoute") } catch (e) { } } } class h extends Error { constructor(e, r) { if (super(`${e} fail, ${r}`), this.fileName = "", this.lineNumber = 1, this.columnNumber = -1, this.name = this.constructor.name, !this.stack) return; const [, n, t = 1, o] = this.stack.match(/\/([\/\w-_\.]+\.js):(\d*):(\d*)/) || []; this.fileName = n, this.lineNumber = Number(t), this.columnNumber = Number(o) } } const P = "MACLE_ERROR_LOG", R = { normalError(e) { console.error(null == e ? void 0 : e.message), O(P, { key: e.key || "MacleApiError", errorStack: e.message, apiName: e.apiName, keywords: e.keywords, fwkVersion: "", file: e.file, line: e.line, column: e.column, timestamp: Date.now() }) } }; function y(e, r, n = !0) { let t, o, a = r; if (n && (a = function (e) { const r = e.split("?"); return r[0] += ".html", void 0 === r[1] ? r[0] : `${r[0]}?${r[1]}` }(a)), a.startsWith("/")) return a.substr(1); if (a.startsWith("./")) return y(e, a.substr(2), !1); const i = a.split("/"); for (t = 0, o = i.length; t < o && ".." === i[t]; t++); i.splice(0, t); const s = e.length > 0 ? e.split("/") : []; return s.splice(s.length - t - 1, t + 1), s.concat(i).join("/") } function L(e) { const r = e.split("?"), [n, t] = r; if (!t) return e; const o = t.split("&").reduce(((e, r) => { if ("string" == typeof r && r.length > 0) { const n = r.split("="), t = n[0], o = n[1]; e[t] = o } return e }), Object.create(null)), a = []; for (const e in o) a.push(e + "=" + encodeURIComponent(o[e])); return a.length > 0 ? n + "?" + a.join("&") : e } function G(e, r) { const n = d(i); if (null === n) return !0; r.url.startsWith("/") && (r.url = r.url.slice(1)); const t = (o = r.url, null == n ? void 0 : n.list.find((e => 0 === o.indexOf(e.pagePath)))); var o; return e !== f.MiniProgram.NAVIGATE_TO && e !== f.MiniProgram.REDIRECT_TO || !t ? !(e === f.MiniProgram.SWITCH_TAB && !t) || (k(e, `${e}: can not ${e} to a non-tabbar page`), !1) : (k(e, `${e}: can not ${e} to a tabbar page`), !1) } function C(e) { return /^(http|https):\/\/.*/i.test(e) } function U(e) { return Object.prototype.toString.call(e).split(" ")[1].split("]")[0] } function k(e, r) { const n = new h(e, r); return R.normalError({ message: n.message, file: n.fileName, line: n.lineNumber, column: n.columnNumber }), n } function M(e, r) { if (w(e) && D(r) && Object.keys(r).length) { const n = e.split("?")[0], t = e.split("?")[1], o = {}; t && t.split("&").forEach((e => { e.length && (o[e.split("=")[0]] = e.split("=")[1]) })); const a = {}; for (const [e, n] of Object.entries(r)) D(n) ? a[e] = JSON.stringify(n) : a[e] = n; return `${n}?${function (e) { if (!D(e)) return e; const r = []; for (const n in e) try { r.push(`${encodeURIComponent(n)}=${encodeURIComponent(e[n])}`) } catch (t) { r.push(`${n}=${e[n]}`) } return r.join("&") }(function (e, r) { for (const [n, t] of Object.entries(r)) e[n] = t; return e }(o, a))}` } return e } function w(e) { return "String" === U(e) } function D(e) { return "Object" === U(e) } function H(e, r, n) { var t; const o = k(e, n); if (!r.success && !r.fail && !r.complete) return new Promise(((e, n) => { r.fail = n, r.fail({ errMsg: o.message }) })); for (const e of ["fail", "complete"]) { null === (t = r[e]) || void 0 === t || t.call(r, { errMsg: o.message }) } return null } function F(e, r, n, t = "parameter") { let o = ""; const a = U(r), i = U(n); if (a !== i) return o = `${t} should be ${i} instead of ${a};`, r.invalidParamObj = H(e, r, o), !1; if ("Object" !== i) return !0; for (const [e, t] of Object.entries(n)) if (Object.prototype.hasOwnProperty.call(r, e)) { const n = U(t), a = U(r[e]); n !== a && (o += `${e} should be ${n} instead of ${a};`) } return !o || (r.invalidParamObj = H(e, r, o), !1) } function j(e, r = {}, n) { n && "function" == typeof n ? b.invoke(e, r, ((r, t) => { 0 === Number(r) ? n(t) : k(e, `${t.errMsg}`) })) : k(e, "callback should be function!") } const B = { miniProgram: { getEnv: function (e) { e({ miniprogram: "miniprogram" === window.__ma_environment }) }, navigateTo: function (e) { if (!e.url) return H(f.MiniProgram.NAVIGATE_TO, e, "parameter error:parameter.url should be String instead of Undefined."); const r = e; r.url = y(d(o), r.url), r.url = L(r.url), G(f.MiniProgram.NAVIGATE_TO, r) && b.beforeInvoke(f.MiniProgram.NAVIGATE_TO, r) }, navigateBack: function (e) { const r = Object.assign({ delta: 1 }, e); b.beforeInvoke(f.MiniProgram.NAVIGATE_BACK, r) }, switchTab: function (e) { if (!e.url) return H(f.MiniProgram.SWITCH_TAB, e, "parameter error:parameter.url should be String instead of Undefined."); const r = e; r.url = y(d(o), r.url), r.url = L(r.url), G(f.MiniProgram.SWITCH_TAB, r) && b.beforeInvoke(f.MiniProgram.SWITCH_TAB, r) }, reLaunch: function (e) { if (!e.url) return H(f.MiniProgram.RE_LAUNCH, e, "parameter error:parameter.url should be String instead of Undefined."); const r = e; r.url = y(d(o), r.url), r.url = L(r.url), G(f.MiniProgram.RE_LAUNCH, r) && b.beforeInvoke(f.MiniProgram.RE_LAUNCH, r) }, redirectTo: function (e) { if (!e.url) return H(f.MiniProgram.REDIRECT_TO, e, "parameter error:parameter.url should be String instead of Undefined."); const r = e; r.url = y(d(o), r.url), r.url = L(r.url), G(f.MiniProgram.REDIRECT_TO, r) && b.beforeInvoke(f.MiniProgram.REDIRECT_TO, r) }, postMessage: function (e) { b.beforeInvoke(f.MiniProgram.POST_MESSAGE, e) }, close: function () { b.invokeMethod(f.MiniProgram.CLOSE) }, navigateBackMiniProgram() { }, onWebviewEvent() { }, offWebviewEvent() { }, sendWebviewEvent() { }, onShow() { }, onHide() { }, onUnload() { } }, chooseImage: function (e) { const r = Object.assign({ count: 9, sizeType: ["original", "compressed"], sourceType: ["album", "camera"] }, e); return b.beforeInvoke(f.Native.CHOOSE_IMAGE, r) }, getLocation: function (e) { const r = Object.assign({ useFetchData: !1 }, e); return b.beforeInvoke(f.Native.GET_LOCATION, r) }, openDocument: function (e) { return (null == e ? void 0 : e.filePath) ? e.fileType && -1 === ["doc", "docx", "xls", "xlsx", "ppt", "pptx", "pdf"].indexOf(e.fileType) ? H(f.Native.OPEN_DOCUMENT, e, "parameter error:parameter.fileType is invalid value.") : b.beforeInvoke(f.Native.OPEN_DOCUMENT, e) : H(f.Native.OPEN_DOCUMENT, e, "parameter error:parameters.filePath should be String instead of Undefined.") }, getStorage: function (e) { if (!(null == e ? void 0 : e.key)) return H(f.Native.GET_STORAGE, e, "parameter error:parameters.key should be String instead of Undefined."); const r = Object.assign({ encrypt: !1 }, e); return b.beforeInvoke(f.Native.GET_STORAGE, r) }, previewImage: function (e) { return (null == e ? void 0 : e.urls) ? b.beforeInvoke(f.Native.PREVIEW_IMAGE, e) : H(f.Native.PREVIEW_IMAGE, e, "parameter error:parameter.urls should be Array instead of Undefined.") }, setStorage: function (e) { if (!(null == e ? void 0 : e.key) || !e.data) return H(f.Native.SET_STORAGE, e, "parameter error:parameter.key or parameter.data should not be Undefined."); const r = Object.assign({ encrypt: !1 }, e); return b.beforeInvoke(f.Native.SET_STORAGE, r) }, removeStorage: function (e) { return (null == e ? void 0 : e.key) ? b.beforeInvoke(f.Native.REMOVE_STORAGE, e) : H(f.Native.REMOVE_STORAGE, e, "parameter error:parameter.key should be String instead of Undefined.") }, clearStorage: function (e) { return b.beforeInvoke(f.Native.CLEAR_STORAGE, e) }, getNetworkType: function (e) { return b.beforeInvoke(f.Native.GET_NETWORK_TYPE, e) }, scanCode: function (e) { const r = ["barCode", "qrCode", "datamatrix", "pdf417"]; if ((null == e ? void 0 : e.scanType) && e.scanType.length > 0 && !e.scanType.every((e => r.indexOf(e) > -1))) return H(f.Native.SCAN_CODE, e, "parameter error:parameter.scanType contains invalid values."); const n = Object.assign({ onlyFromCamera: !1, scanType: ["barCode", "qrCode"] }, e); return b.beforeInvoke(f.Native.SCAN_CODE, n) }, getLocalImgData: function (e) { return (null == e ? void 0 : e.path) ? b.beforeInvoke(f.Native.GET_LOCAL_IMG_DATA, e) : H(f.Native.GET_LOCAL_IMG_DATA, e, "parameter error:parameter.path should be String instead of Undefined.") }, callNativeAPI: j, native: function (e, r) { const n = r || {}; return new Promise(((r, t) => { j(e, n, (e => { r(e) })) })) }, capsuleStyle: function (e) { if (F(f.Native.CAPSULE_STYLE, e, { style: 0 })) { return -1 === [0, 1].indexOf(e.style) ? H(f.Native.CAPSULE_STYLE, e, `parameter error: invalid style ${e.style}`) : b.beforeInvoke(f.Native.CAPSULE_STYLE, e) } return e.invalidParamObj }, getStatusBarHeight: function (e) { return b.beforeInvoke(f.Native.GET_STATUS_BAR_HEIGHT, e) }, showLoading: function (e) { const r = Object.assign({ title: "Loading...", mask: !1 }, e); return F(f.Native.SHOW_LOADING, r, { title: "", mask: !1 }) ? b.beforeInvoke(f.Native.SHOW_LOADING, r) : r.invalidParamObj }, hideLoading: function (e) { return b.beforeInvoke(f.Native.HIDE_LOADING, e) }, saveFileToPhone: function (e) { return e.content ? e.fileName ? F(f.Native.SAVE_FILE_TO_PHONE, e, { content: "", fileName: "" }) ? b.beforeInvoke(f.Native.SAVE_FILE_TO_PHONE, e) : e.invalidParamObj : H(f.Native.SAVE_FILE_TO_PHONE, e, "parameter error:parameter.fileName should be String instead of Undefined.") : H(f.Native.SAVE_FILE_TO_PHONE, e, "parameter error:parameter.content should be String instead of Undefined.") }, showToast: function (e) { var r; if (!(null == e ? void 0 : e.title) && !(null == e ? void 0 : e.message)) return H(f.Native.SHOW_TOAST, e, "parameter error: prompt message should be String instead of Undefined."); if (e.title = null !== (r = e.title) && void 0 !== r ? r : e.message, F(f.Native.SHOW_TOAST, e, { title: "", message: "", icon: "", duration: 0, mask: !1, image: "" })) { const r = ["success", "error", "loading", "none"]; if ((null == e ? void 0 : e.icon) && -1 === r.indexOf(null == e ? void 0 : e.icon)) return H(f.Native.SHOW_TOAST, e, "parameter error:parameter.icon contains invalid values."); const n = Object.assign({ icon: "success", duration: 1500, mask: !1 }, e); return b.beforeInvoke(f.Native.SHOW_TOAST, n) } return e.invalidParamObj }, gotoBrowser: function (e) { return e.openUrl ? F(f.Native.GO_TO_BROWSER, e, { openUrl: "" }) ? b.beforeInvoke(f.Native.GO_TO_BROWSER, e) : e.invalidParamObj : H(f.Native.GO_TO_BROWSER, e, "parameter error:parameter.openUrl should be String instead of Undefined.") }, saveImage: function (e) { return e.content ? F(f.Native.SAVE_IMAGE, e, { content: "" }) ? b.beforeInvoke(f.Native.SAVE_IMAGE, e) : e.invalidParamObj : H(f.Native.SAVE_IMAGE, e, "parameter error:parameter.content should be String instead of Undefined.") }, saveBase64Image: function (e) { return e.base64 ? F(f.Native.SAVE_BASE64_IMAGE, e, { base64: "" }) ? b.beforeInvoke(f.Native.SAVE_BASE64_IMAGE, e) : e.invalidParamObj : H(f.Native.SAVE_BASE64_IMAGE, e, "parameter error:parameter.base64 should be String instead of Undefined.") }, isOnline: function () { return window.navigator.onLine }, chooseContact: function (e) { return b.beforeInvoke(f.Native.CHOOSE_CONTACT, e) }, getsmallappinfo: function (e) { return b.beforeInvoke(f.Native.GET_SMALL_APP_INFO, e) }, downloadFile: function (e) { return e.url ? C(e.url) ? b.beforeInvoke(f.Native.DOWNLOAD_FILE, e) : H(f.Native.DOWNLOAD_FILE, e, `parameter error: invalid url ${e.url}`) : H(f.Native.DOWNLOAD_FILE, e, "parameter error: parameter.url should be String instead of Undefined.") }, request: function (e) { const r = function (e) { let r = ""; e.url || (r = "parameter error: parameter.url should be String instead of Undefined."); C(e.url) || (r = `parameter error: invalid url ${e.url}`); e.data && "Function" === U(e.data) && (r = "parameter error: data should not be Function."); return r }(e); if (r) return H(f.Native.REQUEST, e, r); e.header && !D(e.header) && (e.header = {}), e.header = function (e) { const r = {}; for (const n in e) switch (U(e[n])) { case "String": r[n] = e[n]; break; case "Number": case "Boolean": r[n] = `${e[n]}`; break; default: r[n] = JSON.stringify(e[n]) }return r }(e.header || {}); for (const r in e.header) if ("content-type" === r.toLowerCase()) { const n = e.header[r]; delete e.header[r], e.header[r.toLowerCase()] = n } e.method = e.method ? e.method.toUpperCase() : "GET", e.dataType = e.dataType || "json", e.header["content-type"] = e.header["content-type"] || "application/json"; let n = ""; e.data && (n = D(e.data) ? JSON.stringify(e.data) : e.data), "GET" === e.method && (e.url = M(e.url, e.data || {})); const t = Object.assign({ data: n }, e); return b.beforeInvoke(f.Native.REQUEST, t, { beforeSuccess(r) { if ("json" === e.dataType) try { r.data && w(r.data) && (r.data = JSON.parse(r.data)) } catch (r) { k(f.Native.REQUEST, `JSON parse data error from ${e.url}`) } } }) }, uploadFile: function (e) { if (!e.url) return H(f.Native.UPLOAD_FILE, e, "parameter error: parameter.url should be String instead of Undefined."); if (e.files) e.filePath = "", e.name = ""; else { if (!e.filePath) return H(f.Native.UPLOAD_FILE, e, "parameter error: parameter.filePath should be String instead of Undefined."); if (!e.name) return H(f.Native.UPLOAD_FILE, e, "parameter error: parameter.name should be String instead of Undefined.") } return b.beforeInvoke(f.Native.UPLOAD_FILE, e) }, reportLog: function (e) { if (!e.log || !D(e.log) && !w(e.log)) return H(f.Native.REPORT_LOG, e, "parameter error:  parameter.log should be Object or String instead of Undefined."); if (e.level && -1 === ["debug", "info", "error"].indexOf(e.level)) return H(f.Native.REPORT_LOG, e, `parameter error:  invalid level ${e.level}`); D(e.log) && (e.log = JSON.stringify(e.log)); const r = Object.assign({ level: "info" }, e); return b.notifyNative(f.Native.REPORT_LOG, r) }, reportPerformance: function (e) { return e.reportEvent && w(e.reportEvent) ? e.reportParams && D(e.reportParams) ? b.notifyNative(f.Native.REPORT_PERFORMANCE, e) : H(f.Native.REPORT_PERFORMANCE, e, "parameter error:  parameter.reportParams should be Object instead of Undefined.") : H(f.Native.REPORT_PERFORMANCE, e, "parameter error:  parameter.reportEvent should be String instead of Undefined.") }, getBackgroundFetchData: function (e) { return e.fetchType ? b.beforeInvoke(f.Native.GET_BACKGROUND_FETCH_DATA, e) : H(f.Native.GET_BACKGROUND_FETCH_DATA, e, "parameter error:parameter.fetchType should be string instead of Undefined.") }, submitReport: function (e) { return b.beforeInvoke(f.Native.SUBMIT_REPORT, e) }, playAudio: function (e) { return e.url ? C(e.url) ? b.beforeInvoke(f.Native.PLAY_VOICE, e) : H(f.Native.PLAY_AUDIO, e, `parameter error: invalid url ${e.url}`) : H(f.Native.PLAY_AUDIO, e, "parameter error:parameter.url should be String instead of Undefined.") }, stopAudio: function (e) { return b.beforeInvoke(f.Native.STOP_AUOID, e) }, navigateToMiniProgram: function (e) { return e.appId ? F(f.Native.NAVIGATE_TO_MINI_PROGRAM, e, { appId: "", path: "", params: "" }) ? !e.path && e.params ? H(f.Native.NAVIGATE_TO_MINI_PROGRAM, e, "parameter error: there is params but no path.") : b.beforeInvoke(f.Native.NAVIGATE_TO_MINI_PROGRAM, e) : e.invalidParamObj : H(f.Native.NAVIGATE_TO_MINI_PROGRAM, e, "parameter error:parameter.appId should be String instead of Undefined.") }, getLaunchOptionsSync: function () { const e = b.invokeSync(f.Native.GET_LAUNCH_OPTIONS_SYNC); return e && JSON.parse(e) }, getSystemInfoSync: function () { const e = b.invokeSync(f.Native.GET_SYSTEM_INFO_SYNC); return e && JSON.parse(e) }, getOpenUserInfo: function (e) { return b.beforeInvoke(f.Native.GET_OPEN_USER_INFO, e) }, getAuthCode: function (e) { if (!e.scopes) return H(f.Native.GET_AUTH_CODE, e, "parameter error:parameter.scopes should be Array<string> instead of Undefined."); if (F(f.Native.GET_AUTH_CODE, e, { scopes: ["1"] })) { const r = function (e) { const r = ["AUTH_BASE", "AUTH_USER", "SEND_MESSAGE", "USER_NICKNAME", "USER_NAME", "USER_LOGIN_ID", "PLAINTEXT_USER_LOGIN_ID", "HASH_LOGIN_ID", "USER_AVATAR", "USER_GENDER", "USER_BIRTHDAY", "USER_NATIONALITY", "USER_CONTACTINFO", "USER_ADDRESS", "PLAINTEXT_MOBILE_PHONE"]; return e.filter((e => -1 === r.indexOf(`${e}`.toUpperCase()))) }(e.scopes); return r.length > 0 ? H(f.Native.GET_AUTH_CODE, e, `parameter error: invalid scopes ${r}`) : b.beforeInvoke(f.Native.GET_AUTH_CODE, e) } return e.invalidParamObj } }; return "loading" !== document.readyState ? I() : document.addEventListener("DOMContentLoaded", I), window.onerror = function (e, r, n, t, o) { R.normalError({ key: "thirdPageParamsError", message: e, file: r, line: n, column: t }) }, window.ma = B, window.viewLayer = { onInvokeFinished: function (e, r, n) { const t = m[e]; "function" == typeof t && t(r, n), 2 !== Number(r) && delete m[e] }, subscribeHandler: function (e, r) { return (0, N[e])(r) } }, B }));
